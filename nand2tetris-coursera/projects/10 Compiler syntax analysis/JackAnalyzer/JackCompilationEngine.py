# References
# https://github.com/itayabu/nand2tetris/tree/master/ex10
# https://github.com/saikumarm4/Nand2Tetris/blob/master/10/Lexical.py
# https://github.com/kronosapiens/nand2tetris/blob/master/projects/10/JackAnalyzer.py

import JackTokenizer

class JackCompilationEngine:

    def __init__(self, input_file, output_file):
        """
        creates new compilation engine with given input and output
        It gets its input from a JackTokenizer and emits its parsed structure into an output file/stream.

        The output is generated by a series of compilexxx() routines,
        one for every syntactic element xxx of the Jack grammar.

        The contract between these routines is that each compilexxx() routine should
        read the syntactic construct xxx from the input, advance() the tokenizer
        exactly beyond xxx, and output the parsing of xxx.

        Thus, compilexxx()may only be called if indeed xxx is the next syntactic
        element of the input.
        :param input:
        :param output:
        """
        self.tokenizer = JackTokenizer.JackTokenizer(input_file)
        self.parsed_rules = []  # used for keeping track of open and close <> statements
        self.indent = ""
        # initialise expression sets
        self.binary_op = self.binary_op()
        self.unary_op = self.unary_op()
        self.keyword_constant = self.keyword_constant()

        self.output_file = open(output_file, "w")

    def add_indent(self):
        """
        adds four spaces to indent level
        :return: 
        """
        self.indent += "    "

    def delete_indent(self):
        """
        removes four spaces to current indent level
        :return:
        """
        self.indent = self.indent[:-4]

    def write_nonterminal_start(self, rule):
        """
        pdf pg 19 https://www.csie.ntu.edu.tw/~cyy/courses/introCS/14fall/lectures/handouts/lec14_compilerI.pdf
        non-terminals are everything except (keyword, symbol, constant, or identifier)
        If xxx is non-terminal, output:
        <xxx>
            Recursive code for the body of xxx
        </xxx>
        :param rule:
        :return:
        """
        self.output_file.write(self.indent + "<" + rule + ">\n")  # e.g. <classVarDec>
        self.parsed_rules.append(rule)  # add the rule a list, to pop later for write_nonterminal_end
        self.add_indent()

    def write_nonterminal_end(self):
        self.delete_indent()
        rule = self.parsed_rules.pop()  # popped from the list created when writing start, LIFO
        self.output_file.write(self.indent + "</" + rule + ">\n")  # e.g. </classVarDec>

    def write_terminal(self, token, value):
        """
        If xxx is terminal (keyword, symbol, constant, or identifier), output:
        <xxx>
            xxx value
        </xxx>
        :param token:
        :param value:
        :return:
        """
        self.output_file.write(self.indent + "<" + token + "> " + value + " </" + token + ">\n")

    def advance(self):
        """
        pulls the next token and value, writes both
        :return:
        """
        token, value = self.tokenizer.advance()
        self.write_terminal(token, value)

    def next_value_in(self, list_of_exp):
        token, value = self.tokenizer.peek()
        return value in list_of_exp

    def next_value_is(self, val):
        """
        checks if next value to parse is equal to some condition
        :param val:
        :return boolean:
        """
        token, value = self.tokenizer.peek()
        return value == val

    def next_token_is(self, tok):
        """
        checks if next token to parse is equal to some condition
        :param tok:
        :return boolean:
        """
        token, value = self.tokenizer.peek()
        return token == tok

    #####################
    ### Program structure

    def compile_class(self):
        """
        compiles class
        a class begins with a keyword class,
        then we have a class name, which as you will see later on is an identifier.
        Then we have curly left paren { which begins the definition of the class.
        Then we may have zero or more declarations of either fields or static variables.
        So all together we call this class classVarDec.
        And then we may have zero or more subroutine declarations followed a right curly bracket }

        i.e. structure is
        "class" className "{" classVarDec* subroutineDec* "}"
        :return:
        """
        self.write_nonterminal_start("class")
        self.advance()  # get class keyword
        self.advance()  # get class name

        self.advance()  # get { symbol
        # need to check if have any classVarDec
        # unsure if if, try while
        if self.exist_class_var_dec():
            self.compile_class_var_dec()
        # see if any subroutines
        while self.exist_subroutine():
            self.compile_subroutine_dec()
        self.advance()  # get } symbol

        self.write_nonterminal_end()
        self.output_file.close()

    def exist_class_var_dec(self):
        """
        checking if next value is field or static var
        :return boolean:
        """
        return self.next_value_is("field") or self.next_value_is("static")

    def compile_class_var_dec(self):
        """
        compiles field or static declaration
        :return:
        """
        # as long as next value is field or static
        while self.exist_class_var_dec():
            self.write_nonterminal_start("classVarDec")
            self.write_class_var_dec()
            self.write_nonterminal_end()

    def write_class_var_dec(self):
        """
        classVarDec is structured like:
        ("static" | "field") type varName ("," varName)* ";"
        :return:
        """
        self.advance()  # get field or static
        self.advance()  # get var type
        self.advance()  # get var name

        # if next value is , implies still more var names after it
        while self.next_value_is(","):
            self.advance()  # get ,
            self.advance()  # get var name
        self.advance()  # get ;

    def exist_subroutine(self):
        """
        if constructor, function, or method
        :return boolean:
        """
        return self.next_value_is("constructor") or self.next_value_is("function") or self.next_value_is("method")

    def compile_subroutine_dec(self):
        """
        compiles a constructor, function, or method
        subroutine declaration structure is:
        ("constructor"|"function"|"method") ("void"|type) subroutineName "(" parameterList ")" subroutineBody
        :return:
        """
        self.write_nonterminal_start("subroutineDec")
        self.advance()  # get subroutine type
        self.advance()  # get subroutine return type
        self.advance()  # get subroutine name

        self.advance()  # get (
        self.compile_parameter_list()
        self.advance()  # get )
        self.compile_subroutine_body()
        self.write_nonterminal_end()

    def compile_parameter_list(self):
        """
        compiles zero or more parameter lists, excluding enclosing ()
        :return:
        """
        self.write_nonterminal_start("parameterList")
        while self.exist_parameter():
            self.write_parameter()
        self.write_nonterminal_end()

    def exist_parameter(self):
        """

        :return boolean:
        """
        return not self.next_token_is("symbol")

    def write_parameter(self):
        """
        parameter list structure is:
        ( (type varName) ("," type varName)* )? where * is 0 or more times, ? is 0 or 1 times
        :return:
        """
        self.advance()  # get parameter type
        self.advance()  # get var name

        if self.next_value_is(","):
            self.advance()  # get ,
        # note that we get the , after since the while loop above will pick the next parameter, if any

    def compile_subroutine_body(self):
        """
        subroutine body structure is:
        "{" varDec* statements "}"
        :return:
        """
        self.write_nonterminal_start("subroutineBody")
        self.advance()  # get {
        while self.exist_var_dec():
            self.compile_var_dec()  # get varDec*
        self.compile_statements()  # get statements
        self.advance()  # get }
        self.write_nonterminal_end()

    def exist_var_dec(self):
        """

        :return boolean:
        """
        return self.next_value_is("var")

    def compile_var_dec(self):
        """
        var declaration structure is:
        "var" type varName ("," varName)* ";"
        :return:
        """
        self.write_nonterminal_start("varDec")
        self.advance()  # get var
        self.advance()  # get var type
        self.advance()  # get var name

        while self.next_value_is(","):
            self.advance()  # get ,
            self.advance()  # get var name
        self.advance()  # get :
        self.write_nonterminal_end()

    ### End program structure
    #########################

    #########################
    ### Statements

    def compile_statements(self):
        """
        compiles sequence of statements, not including the enclosing {}
        statements can appear 0 or more times
        are either let, if, while, do, return
        :return:
        """
        self.write_nonterminal_start("statements")
        while self.exist_statement():
            if self.next_value_is("let"):
                self.compile_let()
            elif self.next_value_is("if"):
                self.compile_if()
            elif self.next_value_is("while"):
                self.compile_while()
            elif self.next_value_is("do"):
                self.compile_do()
            elif self.next_value_is("return"):
                self.compile_return()
        self.write_nonterminal_end()

    def exist_statement(self):
        """

        :return boolean:
        """
        return self.next_value_is("let") or self.next_value_is("if") or self.next_value_is("while") \
            or self.next_value_is("do") or self.next_value_is("return")

    def compile_let(self):
        """
        structure is:
        "let" varName ("[" expression "]")? "=" expression ";"
        :return:
        """
        self.write_nonterminal_start("letStatement")
        self.advance()  # get let
        self.advance()  # get var name

        if self.next_value_is("["):  # case of varName [expression]; only 0 or 1 times
            self.write_array()

        self.advance()  # get =
        self.compile_expression()  # get expression
        self.advance()  # get ;
        self.write_nonterminal_end()

    def compile_if(self):
        """
        if statement with 0 or 1 else statements
        structure is:
        "if" "(" expression ")" "{" statements "}" ("else" "{" statements "}")?
        :return:
        """
        self.write_nonterminal_start("ifStatement")
        self.advance()  # get if
        self.advance()  # get (
        self.compile_expression()
        self.advance()  # get )

        self.advance()  # get {
        self.compile_statements()
        self.advance()  # get }

        if self.next_value_is("else"):
            self.advance()  # get else
            self.advance()  # get {
            self.compile_statements()
            self.advance()  # get }
        self.write_nonterminal_end()

    def compile_while(self):
        """
        structure is:
        "while" "(" expression ")" "{" statements "}"
        :return:
        """
        self.write_nonterminal_start("whileStatement")
        self.advance()  # get while
        self.advance()  # get (
        self.compile_expression()
        self.advance()  # get )

        self.advance()  # get {
        self.compile_statements()
        self.advance()  # get }
        self.write_nonterminal_end()

    def compile_do(self):
        """
        structure is:
        "do" subroutineCall ";"
        :return:
        """
        self.write_nonterminal_start("doStatement")
        self.advance()  # get do
        self.compile_subroutine_call()
        self.advance()  # get ;
        self.write_nonterminal_end()

    def compile_return(self):
        """
        structure is:
        "return" expression? ";"
        :return:
        """
        self.write_nonterminal_start("returnStatement")
        self.advance()  # get return
        while self.exist_expression():
            self.compile_expression()
        self.advance()  # get ;
        self.write_nonterminal_end()

    ### End statements
    ##################

    ###############
    ### Expressions

    def exist_expression(self):
        """
        expression has at least one term
        :return boolean:
        """
        return self.exist_term()

    def compile_expression(self):
        """
        structure is:
        term (operator term)*
        :return:
        """
        self.write_nonterminal_start("expression")
        self.compile_term()
        while self.next_value_in(self.binary_op):
            self.advance()  # get operator
            self.compile_term()
        self.write_nonterminal_end()

    def exist_term(self):
        """

        :return boolean:
        """
        # the IDENTIFIER should handle varName and subroutineCall
        return self.next_token_is("integerConstant") or self.next_token_is("stringConstant") \
            or self.next_value_in(self.keyword_constant) or self.next_token_is("identifier") \
            or self.next_value_is("(") or self.next_value_in(self.unary_op)

    def compile_term(self):
        """
        structure is:
        integerConstant | stringConstant | keywordConstant | varName |
        varName "[" expression "]" | subroutineCall | "(" expression ")" | unaryOp term
        :return:
        """
        self.write_nonterminal_start("term")

        if self.next_token_is("integerConstant") or self.next_token_is("stringConstant") \
            or self.next_value_in(self.keyword_constant):
            self.advance()  # get constant

        elif self.next_token_is("identifier"):
            # className, varName, or subroutine
            self.advance()  # get class or var name
            if self.next_value_is("["):  # case of varName[expression]
                self.write_array()

            if self.next_value_is("("):  # case of (expression)
                self.advance()  # get (
                self.compile_expression_list()
                self.advance()  # get )

            if self.next_value_is("."):  # case of subroutine call
                self.advance()  # get .
                self.advance()  # get subroutine name
                self.advance()  # get (
                self.compile_expression_list()
                self.advance()  # get )

        elif self.next_value_is("("):
            self.advance()  # get (
            self.compile_expression()
            self.advance()  # get )

        elif self.next_value_in(self.unary_op):
            self.advance()  # get unary operator
            self.compile_term()

        self.write_nonterminal_end()

    def compile_subroutine_call(self):
        """
        structure is:
        subroutineName "(" expressionList ")" |
        (className|varName) "." subroutineName "(" expressionList ")"
        :return:
        """
        # self.write_nonterminal_start("subroutineCall")
        self.advance()  # get class/subroutine/var name
        if self.next_value_is("."):  # case of className.subroutineName
            self.advance()  # get .
            self.advance()  # get subroutine name

        # now we're starting at same point in above structure
        self.advance()  # get (
        self.compile_expression_list()
        self.advance()  # get )
        # self.write_nonterminal_end()

    def compile_expression_list(self):
        """
        structure is:
        (expression ("," expression)* )?
        :return:
        """
        self.write_nonterminal_start("expressionList")
        if self.exist_expression():
            self.compile_expression()

        while self.next_value_is(","):  # multiple expressions
            self.advance()  # get ,
            self.compile_expression()
        self.write_nonterminal_end()

    def write_array(self):
        """
        for [expression] cases
        :return:
        """
        self.advance()  # get [
        self.compile_expression()
        self.advance()  # get ]

    def binary_op(self):
        return {"+", "-", "*", "/", "&amp;", "|", "&lt;", "&gt;", "=",}

    def unary_op(self):
        return {"-", "~"}

    def keyword_constant(self):
        return {"true", "false", "null", "this"}